---
import { Image } from 'astro:assets';
import { getCipher } from '@/data/db';
import CodeBlockWithLength from './CodeWithLength.astro';
import Username from './Username.astro';

interface Props {
  id: string;
}

const { id } = Astro.props;

const cipher = getCipher(id);
if (!cipher) throw new Error(`Cipher not found: ${id}`);

const images = import.meta.glob<{ default: ImageMetadata }>(
  '/src/assets/**/*.{png,webp,jpg,jpeg}',
  { eager: true }
);

const imageSrc = cipher.image
  ? images[`/src/assets/${cipher.image}`]?.default ?? null
  : null;

const alchemySrc = cipher.type === 'alchemy'
  ? images['/src/assets/bo4/alch_symbols.webp']?.default ?? null
  : null;

function formatMethod(method: string): string {
  const upper = ['adfgx', 'adfgvx'];
  if (upper.includes(method)) return method.toUpperCase();
  return method.split('_').map((w: string) => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
}

function stepToHtml(step: any, brief: boolean): string {
  if (step.type === 'puzzle') return step.description;

  if (step.type === 'decode') {
    const method = formatMethod(step.method);
    return brief
      ? `Decode from ${method}.`
      : `This cipher uses ${method} decoding.`;
  }

  if (step.type === 'formula') {
    return brief
      ? `Apply ${step.method}.`
      : `This cipher uses ${step.method}.`;
  }

  if (step.type === 'classical') {
    const name = formatMethod(step.method);
    if (step.configuration) {
      return brief
        ? `${name} cipher with ${step.configuration}.`
        : `This cipher is a ${name} cipher with ${step.configuration}.`;
    }
    if (step.key) {
      return brief
        ? `${name} cipher with key <code>${step.key}</code>.`
        : `This cipher is a ${name} cipher with key <code>${step.key}</code>.`;
    }
    return brief ? `${name} cipher.` : `This cipher is a ${name} cipher.`;
  }

  if (step.type === 'decrypt') {
    const name = formatMethod(step.method);
    const parts = [name];
    if (step.mode) parts.push(`(${step.mode} mode)`);
    if (step.key) parts.push(`with key <code>${step.key}</code>`);
    return brief
      ? `Decrypt with ${parts.join(' ')}.`
      : `This cipher is decrypted with ${parts.join(' ')}.`;
  }

  if (step.type === 'transform') {
    const name = formatMethod(step.method);
    if (step.notes) return brief ? `${name}: ${step.notes}.` : `${name}: ${step.notes}.`;
    if (step.shift !== undefined) {
      return brief
        ? `Apply ${name} by ${step.shift}.`
        : `This cipher uses ${name} by ${step.shift}.`;
    }
    return brief ? `Apply ${name}.` : `This cipher uses a ${name} transform.`;
  }

  if (step.type === 'encode') {
    const name = formatMethod(step.method);
    if (step.notes) return `${name}: ${step.notes}.`;
    return brief ? `Encode as ${name}.` : `This cipher uses ${name} encoding.`;
  }

  return '';
}

const steps = cipher.solution?.steps ?? [];
const isMultiStep = steps.length > 1;
const notes = cipher.solution?.notes ?? null;
const plaintextLines = cipher.plaintext?.split('\n') ?? [];
const solvers: string[] = cipher.solvers;
---

{imageSrc && <Image src={imageSrc} alt={cipher.title} />}

{alchemySrc && (
  <div class="alchemy-guide">
    <p>This cipher is an alchemy cipher that uses this guide:</p>
    <Image src={alchemySrc} alt="Alchemy symbols reference" />
  </div>
)}

<blockquote>
  {solvers.length > 0 ? (
    <p>
      Credit: {solvers.map((name: string, i: number) => (
        <>
          {i > 0 && solvers.length === 2 && ' and '}
          {i > 0 && solvers.length > 2 && i < solvers.length - 1 && ', '}
          {i > 0 && solvers.length > 2 && i === solvers.length - 1 && ', and '}
          <Username name={name} />
        </>
      ))} for solving this cipher.
    </p>
  ) : (
    <p>There is no known first solver for this cipher.</p>
  )}
</blockquote>

<h2 id="solution">Solution</h2>

{isMultiStep ? (
  <ol>
    {steps.map((step: any) => <li set:html={stepToHtml(step, true)} />)}
  </ol>
) : steps.length === 1 ? (
  <p set:html={stepToHtml(steps[0], false)} />
) : null}

{notes && <p>{notes}</p>}

<h2 id="plaintext">Plaintext</h2>

<blockquote>
  {plaintextLines.map((line: string) => <p>{line}</p>)}
</blockquote>

{cipher.ciphertext && (
  <>
    <h2 id="ciphertext">Ciphertext</h2>
    <CodeBlockWithLength code={cipher.ciphertext} />
  </>
)}
