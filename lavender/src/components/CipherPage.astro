---
import { Image } from 'astro:assets';
import { getCipher, getCreditUsers } from '@/data/db';
import CodeBlockWithLength from './CodeWithLength.astro';
import Username from './Username.astro';

interface Props {
  id: string;
}

const { id } = Astro.props;

const cipher = getCipher(id);
if (!cipher) throw new Error(`Cipher not found: ${id}`);

const images = import.meta.glob<{ default: ImageMetadata }>(
  '/src/assets/**/*.{png,webp,jpg,jpeg}',
  { eager: true }
);

const imageSrc = cipher.image
  ? images[`/src/assets/${cipher.image}`]?.default ?? null
  : null;

const alchemySrc = cipher.type === 'alchemy'
  ? images['/src/assets/bo4/alch_symbols.webp']?.default ?? null
  : null;

function formatMethod(method: string): string {
  const upper = ['adfgx', 'adfgvx'];
  if (upper.includes(method)) return method.toUpperCase();
  return method.split('_').map((w: string) => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
}

function stepToHtml(step: any, brief: boolean): string {
  if (step.type === 'puzzle') return step.description;

  if (step.type === 'decode') {
    const method = formatMethod(step.method);
    return brief
      ? `Decode from ${method}.`
      : `This cipher uses ${method} decoding.`;
  }

  if (step.type === 'formula') {
    return brief
      ? `Apply ${step.method}.`
      : `This cipher uses ${step.method}.`;
  }

  if (step.type === 'classical') {
    const name = formatMethod(step.method);
    if (step.configuration) {
      return brief
        ? `${name} cipher with ${step.configuration}.`
        : `This cipher is a ${name} cipher with ${step.configuration}.`;
    }
    if (step.key) {
      return brief
        ? `${name} cipher with key <code>${step.key}</code>.`
        : `This cipher is a ${name} cipher with key <code>${step.key}</code>.`;
    }
    return brief ? `${name} cipher.` : `This cipher is a ${name} cipher.`;
  }

  if (step.type === 'decrypt') {
    const name = formatMethod(step.method);
    const parts = [name];
    if (step.mode) parts.push(`(${step.mode} mode)`);
    if (step.key) parts.push(`with key <code>${step.key}</code>`);
    return brief
      ? `Decrypt with ${parts.join(' ')}.`
      : `This cipher is decrypted with ${parts.join(' ')}.`;
  }

  if (step.type === 'transform') {
    const name = formatMethod(step.method);
    if (step.notes) return brief ? `${name}: ${step.notes}.` : `${name}: ${step.notes}.`;
    if (step.shift !== undefined) {
      return brief
        ? `Apply ${name} by ${step.shift}.`
        : `This cipher uses ${name} by ${step.shift}.`;
    }
    return brief ? `Apply ${name} transformation.` : `This cipher uses a ${name} transform.`;
  }

  if (step.type === 'encode') {
    const name = formatMethod(step.method);
    if (step.notes) return `${name}: ${step.notes}.`;
    return brief ? `Encode as ${name}.` : `This cipher uses ${name} encoding.`;
  }

  return '';
}

const isAlchemy = cipher.type === 'alchemy';
const isSolved = cipher.solution !== null;
const steps = cipher.solution?.steps ?? [];
const isMultiStep = steps.length > 1;
const notes = cipher.solution?.notes ?? null;
const plaintextLines = cipher.plaintext?.split('\n') ?? [];
const solvers: string[] = cipher.solvers;
const creditEntries = cipher.credits.filter(entry => entry.users.length > 0);
---

{imageSrc && <Image src={imageSrc} alt={cipher.title} />}

{!isSolved && !isAlchemy && (
  <blockquote><p>This cipher is unsolved.</p></blockquote>
)}

{alchemySrc && (
  <div class="alchemy-guide">
    <p>This cipher is an alchemy cipher that uses this guide:</p>
    <Image src={alchemySrc} alt="Alchemy symbols reference" />
  </div>
)}

{(isSolved || isAlchemy) && (
  <div class="solver-callout">
    <div class="solver-callout-icon" aria-hidden="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
        <path d="M2.866 14.85c-.078.444.36.791.746.593l4.39-2.256 4.389 2.256c.386.198.824-.149.746-.592l-.83-4.73 3.522-3.356c.33-.314.16-.888-.282-.95l-4.898-.696L8.465.792a.513.513 0 0 0-.927 0L5.354 5.12l-4.898.696c-.441.062-.612.636-.283.95l3.523 3.356-.83 4.73zm4.905-2.767-3.686 1.894.694-3.957a.56.56 0 0 0-.163-.505L1.71 6.745l4.052-.576a.53.53 0 0 0 .393-.288L8 2.223l1.847 3.658a.53.53 0 0 0 .393.288l4.052.575-2.906 2.77a.56.56 0 0 0-.163.506l.694 3.957-3.686-1.894a.5.5 0 0 0-.461 0z"/>
      </svg>
    </div>
    {solvers.length > 0 ? (
      <p>
        Credit: {solvers.map((name: string, i: number) => (
          <>
            {i > 0 && solvers.length === 2 && ' and '}
            {i > 0 && solvers.length > 2 && i < solvers.length - 1 && ', '}
            {i > 0 && solvers.length > 2 && i === solvers.length - 1 && ', and '}
            <Username name={name} />
          </>
        ))} for solving this cipher.
      </p>
    ) : (
      <p>There is no known first solver for this cipher.</p>
    )}
  </div>
)}

{creditEntries.length > 0 && (
  <blockquote>
    {creditEntries.map((entry) => (
      <p>
        Additional credit{entry.users.length > 1 ? 's' : ''} to {entry.users.map((name: string, i: number) => (
          <>
            {i > 0 && entry.users.length === 2 && ' and '}
            {i > 0 && entry.users.length > 2 && i < entry.users.length - 1 && ', '}
            {i > 0 && entry.users.length > 2 && i === entry.users.length - 1 && ', and '}
            <Username name={name} />
          </>
        ))}{entry.note ? ` for ${entry.note}.` : ' for helping along the way.'}
      </p>
    ))}
  </blockquote>
)}

{isSolved && !isAlchemy && (
  <>
    <h2 id="solution">Solution</h2>

    {isMultiStep ? (
      <ol>
        {steps.map((step: any) => <li set:html={stepToHtml(step, true)} />)}
      </ol>
    ) : steps.length === 1 ? (
      <p set:html={stepToHtml(steps[0], false)} />
    ) : null}

    {notes && <p>{notes}</p>}
  </>
)}

{plaintextLines.length > 0 && (
  <>
    <h2 id="plaintext">Plaintext</h2>
    <blockquote>
      {plaintextLines.map((line: string) => <p>{line}</p>)}
    </blockquote>
  </>
)}

{cipher.ciphertext && (
  <>
    <h2 id="ciphertext">Ciphertext</h2>
    <CodeBlockWithLength code={cipher.ciphertext} />
  </>
)}

<style>
  .solver-callout {
    display: flex;
    gap: 0.75rem;
    align-items: flex-start;
    padding: 1rem 1.25rem;
    border: 1px solid rgba(212, 175, 55, 0.25);
    border-inline-start: 4px solid #d4af37;
    border-radius: 0.5rem;
    background: rgba(212, 175, 55, 0.06);
    margin: 1rem 0;
  }

  .solver-callout-icon {
    flex-shrink: 0;
    color: #d4af37;
    margin-top: 0.15rem;
  }

  .solver-callout p {
    margin: 0;
    line-height: 1.6;
  }
</style>
